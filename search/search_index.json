{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"User Guide","text":"<p>A modern JavaScript tree/treegrid control.</p> <p>Info</p> <p>Wunderbaum has beta status: API, Markup, Stylesheet, etc. are still subject to change.</p> <ul> <li>Quick Start</li> <li>API Reference</li> <li>Online Demo</li> <li>Source Code on GitHub</li> </ul> <p></p> <ul> <li>Supports drag and drop, editing, filtering, sorting, and multi-selection.</li> <li>Written in TypeScript, transpiled to ES6 (esm &amp; umd).</li> <li>Performant handling of big data structures.</li> <li>Provide an object oriented API.</li> <li>Framework agnostic.</li> <li>Zero dependencies.</li> <li>Keyboard support.</li> </ul>"},{"location":"tutorial/concepts/","title":"Concepts","text":"<p>This document describes some general concepts of Wunderbaum.</p>"},{"location":"tutorial/concepts/#design-goals","title":"Design Goals","text":"<ul> <li>Implement a treegrid control with emphasis on \"tree\".   Depending on the number of columns and nesting depth, Wunderbaum can also be   used as a plain tree, plain grid, or a simple list control.</li> <li>Performant and efficient handling of big data structures.</li> <li>Use modern technologies with zero dependencies (except for icon fonts you   may want to use).   Drop legacy support (IE, jQuery, ...).</li> <li>Robust, consistent handling of parallel, asynchronous behavior.</li> <li>Built-in support for   </li> </ul> <p>drag and drop,   editing,   filtering,   multi-selection. - Fully controllable using the keyboard. - Framework agnostic. - Good documentation.</p> <ul> <li>Written in TypeScript, transpiled to JavaScript ES6 with type hints (.esm &amp; .umd).</li> </ul>"},{"location":"tutorial/concepts/#main-concepts","title":"Main Concepts","text":"<p>We have a tree data model as the backbone, i.e. an instance of the <code>Wunderbaum</code> class that contains a hierarchical structure of <code>WunderbaumNode</code> objects.</p> <p>A node may be active, selected, focused, and/or hovered. These node states are independent, so one node can have all, some, or none of these states at the same time. See [[FAQ]] 'What statuses can a node have?'.</p> <p>This structure is initialized on startup from a JavaScript data structure, an Ajax JSON response or a generator function.</p> <p>The tree's data model can be accessed and modified using an extensive object oriented API like <code>tree.getNodeByKey()</code>, <code>node.setTitle()</code>, or <code>node.setExpanded()</code>.</p> <p>The rectangular, scrollable area on the page, that contains the (potentially much larger) tree is called viewport. HTML markup is rendered on demand, i.e. only for nodes that are visible inside the viewport. Also children of collapsed parent nodes don't have HTML elements. This concept allows to hold a huge data model (100k+ nodes) in the frontend, while only having a few HTML elements materialized in the DOM. Developers should not manipulate the html directly, but change the data model and then call <code>tree.update()</code> or <code>node.update()</code> if needed. Due to lazy rendering, it is not possible to bind events to all node HTML elements directly. However this is rarely necessary, since Wunderbaum offers event handlers like <code>click</code>, <code>dblclick</code>, and <code>keypress</code>. Use event delegation otherwise.</p> <p>A tree is usually set up for lazy loading: For one thing, the tree initialization may be delayed to an asynchronous Ajax request. This will result in a fast page load, and an empty tree displaying a spinner icon until the data arrives. Additionally, single child nodes may be marked 'lazy'. These nodes will generate Ajax requests when expanded for the first time. Lazy loading allows to present hierarchical structures of infinite size in an efficient way. But since neither all DOM elements nor even the complete tree data model is available in the browser, API functions like <code>tree.getNodeByKey()</code> or <code>node.findAll()</code> may not work as expected.</p> <p>Some API functions are potentially asynchronous. For example <code>node.setExpanded()</code> on a lazy node may have to issue an Ajax request, wait for its response and then scroll and render new nodes. These functions generally return a <code>Promise</code>, so handling deferred responses is easy:</p> <pre><code>node.setExpanded().then(() =&gt; {\n  alert(\"expand has finished\");\n});\n</code></pre> <p>or</p> <pre><code>await tree.expandAll();\nalert(\"expand has finished\");\n</code></pre> <p>Activities and state changes generate events. Event handlers are used to implement behavior:</p> <pre><code>const tree = new Wunderbaum({\n  // ...\n  activate: (e) =&gt; {\n    console.log(\"Node was activated:\", e.node);\n  },\n  change: (e) =&gt; {\n    console.log(\"Grid data was modified:\", e);\n  },\n  render: (e) =&gt; {\n    // e.node was rendered. We may now modify the markup...\n  },\n});\n</code></pre>"},{"location":"tutorial/contribute/","title":"Contributors Guide","text":"<p>First off: thank you for your contribution :heart:  This open source project would not be possible without your support!</p> <p>There are many ways how you can help:</p> <ul> <li>Use and test the library. Provide constructive feedback.</li> <li>Spread the word: Star this GitHub project, share links, or mention it if you   find it useful.</li> <li>Improve the documentation.</li> <li>Report - or fix - bugs (see below).</li> <li>Suggest - or implement - new features (see below).</li> <li>Donate.</li> </ul>"},{"location":"tutorial/contribute/#report-bugs","title":"Report Bugs","text":"<p>Issues can be reported in the bug tracker.</p> <p>Info</p> <p>Try your best to make fixing as easy as possible. Do not assume that bugs are fixed, just because they are reported: Please understand that issues are likely to be closed, if they are hard to reproduce.</p> <p>A bug report should contain:</p> <ul> <li>A short description of the problem.</li> <li>A minimal, reproducible example:</li> <li>See here for a wunderbaum triage template.      Copy and rename this file, then edit it to reproduce the issue.     It can be opened directly in the browser.</li> <li>See here for a wunderbaum JS Bin template.     Copy and edit this template to reproduce the issue.</li> <li>The expected result.</li> <li>The actual result.</li> <li>The version of the library.</li> <li>The version of the browser.</li> </ul> <p>Of course a pull request is the most welcomed form of contribution. \ud83d\ude09 Do not forget to add an entry to the <code>CHANGELOG.md</code>.</p>"},{"location":"tutorial/contribute/#request-new-features","title":"Request New Features","text":"<p>Features can be requested and discussed in the bug tracker, or - often more adequate - in the discussion forum.</p> <p>Info</p> <p>Please understand that feature requests sometimes are rejected due to the lack of resources, or because they do not fit into the greater plan or paradigm. This does not mean that the proposal is bad, so do not feel offended.</p> <p>If you plan to contribute a feature via a pull request we highly recommend to discuss the approach beforehand to avoid effort.</p> <p>Keep in mind that a feature implementation also includes tests, documentation, and updates to the demo page.</p>"},{"location":"tutorial/contribute/#development","title":"Development","text":""},{"location":"tutorial/contribute/#edit-typescript-sources","title":"Edit TypeScript sources","text":"<p>install node.js 18+ Checkout the project from GiHub, then</p> <p><pre><code>$ cd path/to/project\n$ corepack enable\n$ corepack install\n</code></pre> <pre><code>$ cd path/to/project\n$ yarn\n$ yarn dev\n</code></pre></p> <p>You can now edit the files in <code>.../wunderbaum/src</code> folder. TypeScript and SCSS files are automatically transpiled to the <code>.../wunderbaum/build</code> folder.</p> <p>Reformat according to the style guide, run unit tests, build, or compile a version using these commands:</p> <pre><code>$ yarn format\n$ yarn test\n</code></pre> <p>Note</p> <p>Don't forget to call <code>yarn format</code> regularly and before committing: Formatting errors will be rejected by the CI pipeline.</p>"},{"location":"tutorial/contribute/#edit-documentation","title":"Edit Documentation","text":"<p>The documentation is written in Markdown and can be found in the <code>docs</code> folder.</p> <p>The User Guide is generated using MkDocs and the API documentation is generated using TypeDoc.</p> <p>API Documentation</p> <p>The API reference is generated from the TypeScript sources by TypeDoc and the resulting files are stored in the <code>docs/api</code> folder.</p> <p>This is done by the build script or manually by running:</p> <pre><code>$ yarn api_docs\n</code></pre> <p>User Guide</p> <p>The user guide (i.e. tutorial) is written in Markdown and can be found in the <code>docs/tutorial</code> folder. It is rendered to HTML using MkDocs by a GitHub action and published as GitHub pages every time we commit.</p> <p>Note</p> <p>In order to generate the User Guide documentation locally, we need to have Python and pipenv installed.</p> <p>Then install the required packages:</p> <pre><code>$ cd path/to/project\n$ pipenv install\n</code></pre> <p>Run the following command to start the MkDocs server:</p> <pre><code>$ yarn dev_mkdocs\n</code></pre> <p>You can now edit files in the <code>docs/tutorial</code> folder and see the changes in the browser.</p>"},{"location":"tutorial/contribute/#release","title":"Release","text":"<p>For a local test build, run the following commands:</p> <pre><code>$ yarn build\n</code></pre> <p>A new version is released by creating a new tag in the format <code>vX.Y.Z</code> and</p> <pre><code>$ grunt yabs:release:patch\n</code></pre>"},{"location":"tutorial/migrate/","title":"Migrate from Fancytree to Wunderbaum","text":""},{"location":"tutorial/migrate/#what-has-changed","title":"What has Changed?","text":"<p>Main Changes to Fancytree:</p> <ul> <li>Written in TypeScript, transpiled to JavaScript ES6 with type hints (.esm &amp; .umd).</li> <li>Removed dependecy on jQuery and jQuery UI.</li> <li>Dropped support for Internet Explorer.</li> <li>Markup is now <code>&lt;div&gt;</code> based, instead of <code>&lt;ul&gt;/&lt;li&gt;</code> and <code>&lt;table&gt;</code>.</li> <li>Grid layout is now built-in standard. A plain tree is only a special case thereof.</li> <li>New viewport concept (implies a fixed header and a scrollable body).</li> <li>'Clone' suppport is now built-in standard (i.e. support for duplicate   <code>refKey</code>s in addition to unique <code>key</code>s).</li> <li>Built-in html5 drag'n'drop.</li> <li>Titles are always XSS-safe now (former explicit <code>escapeTitles: true</code>).</li> <li>'folder' is no longer a special built-in node type. Instead, the application   can define any number of node types.</li> </ul> <p>Missing Features (as of today)</p> <ul> <li>Persistence</li> </ul>"},{"location":"tutorial/migrate/#migration-guide","title":"Migration Guide","text":"<p>Many general concepts from Fancytree are still the same, see the Concepts for a general overview.</p> <p>Especially the rendering model and grid support has changed significantly, however.</p> Feature Fancytree Wunderbaum Dependency Requires jQuery and jQuery UI No dependency on jQuery Browser Support Supports Internet Explorer Dropped support for Internet Explorer Markup <code>&lt;ul&gt;/&lt;li&gt;</code> and <code>&lt;table&gt;</code> based <code>&lt;div&gt;</code> based Layout Grid layout as an extension Grid layout built-in Viewport No built-in viewport concept New viewport concept with fixed header and scrollable body Drag and Drop Requires additional plugins Built-in HTML5 drag and drop XSS Safety Requires <code>escapeTitles: true</code> Titles are always XSS-safe Node Types 'folder' as a special node type Application-defined node types Performance Lazy rendering of HTML elements, but may be slow with large number of expanded nodes. Handles large number of nodes (100k+)"},{"location":"tutorial/migrate/#replace-the-script-and-css-dependencies","title":"Replace the Script and CSS dependencies","text":"Init Fancytree Wunderbaum Tutorial Tutorial Tutorial"},{"location":"tutorial/migrate/#tree-options","title":"Tree Options","text":"<p>Options are mostly the same, but some property names have changed.  Major changes were made to the <code>grid</code> and <code>dnd</code> configuration.</p> Options Fancytree Wunderbaum Reference API API Tutorial Docs Docs"},{"location":"tutorial/migrate/#tree-and-node-properties","title":"Tree and Node Properties","text":"<ul> <li><code>refKey</code> and <code>refType</code> are now direct properties of the node object.</li> <li><code>node.folder</code> was dropped in favor af a more general <code>node.type</code> property.</li> </ul> Properties Fancytree Wunderbaum Tree Reference Tree model Tree model Node Reference Node model Node model Tutorial \u2014 Tutorial"},{"location":"tutorial/migrate/#data-format","title":"Data Format","text":"<p>The data format is mostly the same, but some property names have changed. For example, <code>folder</code> is now <code>type: \"folder\"</code>.</p> Data Fancytree Wunderbaum Reference \u2014 Initialize \u2014 Formats Tutorial Tutorial Tutorial"},{"location":"tutorial/migrate/#api-calls","title":"API Calls","text":"<p>The API is similar, but some method names and signatures have changed.</p> API Fancytree Wunderbaum Reference Tree API Tree API Node API NodeAPI Tutorial Tutorial Tutorial"},{"location":"tutorial/migrate/#event-handlers","title":"Event Handlers","text":"<p>The signature of event handlers has changed from <code>function(event, data)</code> to <code>function(event)</code>.</p> Events Fancytree Wunderbaum Reference Handler API Handler API Event model Event model Tutorial Tutorial Tutorial"},{"location":"tutorial/quick_start/","title":"Quick Start","text":"<p>Note</p> <p>Wunderbaum has beta status: API, Markup, Stylesheet, etc. are still subject to change.</p> <p>A Wunderbaum control is added to a web page by defining a <code>&lt;div&gt;</code> tag and then create a new Wunderbaum class instance, passing the tag and configuration options.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;!-- Additional icon fonts. Wunderbaum uses bootstrap icons by default. --&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      href=\"https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css\"\n    /&gt;\n    &lt;!-- Wunderbaum CSS and Library --&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      href=\"https://cdn.jsdelivr.net/npm/wunderbaum@0/dist/wunderbaum.min.css\"\n    /&gt;\n    &lt;script\n      defer\n      src=\"https://cdn.jsdelivr.net/npm/wunderbaum@0/dist/wunderbaum.umd.min.js\"\n    &gt;&lt;/script&gt;\n    &lt;!-- Your application code --&gt;\n    &lt;script&gt;\n      data = [\n        {\n          title: \"Node 1\",\n          expanded: true,\n          children: [\n            {\n              title: \"Node 1.1\",\n            },\n            {\n              title: \"Node 1.2\",\n            },\n          ],\n        },\n        {\n          title: \"Node 2\",\n        },\n      ];\n\n      document.addEventListener(\"DOMContentLoaded\", (event) =&gt; {\n        const tree = new mar10.Wunderbaum({\n          element: document.getElementById(\"demo-tree\"),\n          source: data,\n          init: (e) =&gt; {\n            e.tree.setFocus();\n          },\n          activate: (e) =&gt; {\n            alert(`Thank you for activating ${e.node}.`);\n          },\n        });\n      });\n    &lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    ...\n    &lt;div\n      id=\"demo-tree\"\n      class=\"wb-skeleton wb-initializing wb-fade-expander\"\n    &gt;&lt;/div&gt;\n    ...\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>ESM modules are also supported:</p> <pre><code>&lt;script type=\"module\"&gt;\n  import wunderbaum from \"https://cdn.jsdelivr.net/npm/wunderbaum@0/+esm\";\n&lt;/script&gt;\n</code></pre> <p>Info</p> <p>Wunderbaum is a refactored version of Fancytree.</p> <p>Read migrate for details and migration hints.</p> <p>See also</p> <p>See also the API Documentation and the live demo.</p>"},{"location":"tutorial/tutorial_api/","title":"Tree API","text":"<p>TL;DR</p> <p>Wunderbaum offers an extensive, object oriented API.</p> <p>Warning</p> <p>This chapter is still under construction.</p> <p>See also</p> <p>See also the API Reference.</p> <p>This chapter describes different ways to modify the tree model using the API.</p>"},{"location":"tutorial/tutorial_api/#iteration","title":"Iteration","text":"<ul> <li>tree.visit()</li> </ul> <p>There are two ways to traverse the tree depth-first, pre-order:</p> <pre><code>for (const node of tree) {\n  node.log();\n}\n</code></pre> <pre><code>tree.visit((node) =&gt; {\n  node.log();\n});\n</code></pre> <p>Both are 'fast enough' for most use cases, but the latter is slightly faster.</p> <p><code>visit()</code> also allows to break or skip nodes by returning a special value:</p> <pre><code>tree.visit((node) =&gt; {\n  if (node.isSelected()) {\n    return \"skip\"; // skip selected nodes and their children\n  }\n  if (node.title === \"foo\") {\n    return false; // stop iteration\n  }\n});\n</code></pre> <p>Iteration is also available for subnodes:</p> <pre><code>for(const node of parentNode) {\n  ...\n}\nparentNode.visit((node) =&gt; {\n  ...\n});\n</code></pre> <p>Related Methods</p> <ul> <li>tree.visit()</li> </ul>"},{"location":"tutorial/tutorial_api/#searching","title":"Searching","text":"<p>See Search and Filter Nodes.</p>"},{"location":"tutorial/tutorial_api/#selection","title":"Selection","text":"<p>See Search and Filter Nodes.</p>"},{"location":"tutorial/tutorial_api/#sorting","title":"Sorting","text":"<p>See Search and Filter Nodes.</p>"},{"location":"tutorial/tutorial_api/#mutation","title":"Mutation","text":""},{"location":"tutorial/tutorial_api/#adding-nodes","title":"Adding Nodes","text":""},{"location":"tutorial/tutorial_api/#removing-nodes","title":"Removing Nodes","text":""},{"location":"tutorial/tutorial_api/#moving-nodes","title":"Moving Nodes","text":""},{"location":"tutorial/tutorial_api/#changing-node-properties","title":"Changing Node Properties","text":""},{"location":"tutorial/tutorial_api/#changing-node-state","title":"Changing Node State","text":""},{"location":"tutorial/tutorial_api/#changing-node-data","title":"Changing Node Data","text":""},{"location":"tutorial/tutorial_api/#changing-node-style","title":"Changing Node Style","text":""},{"location":"tutorial/tutorial_api/#changing-node-class","title":"Changing Node Class","text":""},{"location":"tutorial/tutorial_api/#changing-node-attributes","title":"Changing Node Attributes","text":""},{"location":"tutorial/tutorial_api/#changing-node-icons","title":"Changing Node Icons","text":""},{"location":"tutorial/tutorial_api/#changing-node-badge","title":"Changing Node Badge","text":""},{"location":"tutorial/tutorial_api/#changing-node-badge-colors","title":"Changing Node Badge Colors","text":""},{"location":"tutorial/tutorial_api/#related-methods","title":"Related Methods","text":"<ul> <li><code>node.moveTo()</code></li> <li><code>node.setExpanded()</code></li> <li><code>node.setSelected()</code></li> <li><code>tree.applyCommand()</code></li> </ul>"},{"location":"tutorial/tutorial_api/#utility-methods","title":"Utility Methods","text":"<p>The Module util provides a number of utility methods that are useful when working with trees.</p>"},{"location":"tutorial/tutorial_api/#performance-tips","title":"Performance Tips","text":"<p>Use <code>tree.runWithDeferredUpdate()</code> to avoid multiple updates while changing many nodes at once.  Synchronous methods can be wrapped in a <code>runWithDeferredUpdate()</code> call to avoid multiple redraws:</p> <pre><code>tree.runWithDeferredUpdate(() =&gt; {\n  tree.visit((node) =&gt; {\n    node.setSelected(true);\n  });\n});\n</code></pre> <p>Asynchronous methods can be wrapped in a <code>runWithDeferredUpdateAsync()</code> like so:</p> <pre><code>await tree.runWithDeferredUpdateAsync(async () =&gt; {\n  return await node.someAsyncFuntion();\n});\n</code></pre>"},{"location":"tutorial/tutorial_dnd/","title":"Drag and Drop","text":"<p>TL;DR</p> <p>Wunderbaum implements drag and drop according to the native HTML protocol. This allows interaction between different tree instances, browsers, and even native applcations.</p> <p>Wunderbaum supports drag and drop of nodes within the tree and between trees. It is also possible to drag nodes from the tree to other elements on the page or vice versa. Even cross-window drag and drop is supported.  The implementation is purely based on the native HTML Drag and Drop API.</p> <p>Note that there is no automatic modification of nodes. Instead, the <code>drop</code> event is fired on the target tree and it is up to the application to modify the tree accordingly.</p>"},{"location":"tutorial/tutorial_dnd/#drag-and-drop-events","title":"Drag and Drop Events","text":"<p>The following events are fired on the tree during drag and drop.</p> <p>Info</p> <p>Note that the <code>dragStart</code>, <code>drag</code>, and <code>dragEnd</code> events are fired on the tree that contains the dragged node (i.e. the source node).  The other events are fired on the tree that contains the drop target.</p> <p>The events are named after the corresponding HTML Drag and Drop events. However, the event handlers are passed an object with the following properties:</p> <pre><code>e = {\n  type: \"dnd.EVENTNAME\",\n  node: // the source or target node, depending on the event type\n  event: // &lt;the original HTML DragEvent&gt;\n}\n</code></pre> <p>These are events are sent in a typical drag and drop operation:</p> <ul> <li> <p><code>dragStart(e)</code>: Fired when a drag operation is started.   This event handler MUST be implemented by the application in order to enable   dragging in general.    The handler can return <code>false</code> to prevent dragging the source node.   The handler can set the <code>e.event.dataTransfer.effectAllowed</code> property in order   to adjust copy/move/link behavior.    The handler can set the <code>e.event.dataTransfer.dropEffect</code> property in order to   adjust copy/move/link behavior.</p> </li> <li> <p><code>drag(e)</code>: Fired repeadedly during a drag operation.   We will hardly ever have to implement this handler.</p> </li> <li> <p><code>dragEnter(e)</code>: Fired when a dragged item enters a drop target.   This event handler MUST be implemented by the application in order to enable   dropping in general.    The handler can return <code>false</code> to prevent the drop operation or return a set   of drop regions to indicate which drop regions are allowed.    The handler can set the <code>e.event.dataTransfer.dropEffect</code> property in order to   adjust copy/move/link behavior.</p> </li> <li> <p><code>dragOver(e)</code>: Fired continuously when a dragged item is moved over a drop target.    We will hardly ever have to implement this handler.    The handler can set the <code>e.event.dataTransfer.dropEffect</code> property in order to   adjust copy/move/link behavior.</p> </li> <li> <p><code>dragLeave(e)</code>: Fired when a dragged node leaves a drop target.    We will hardly ever have to implement this handler.</p> </li> <li> <p><code>drop(e)</code>: Fired when a dragged node is dropped on a drop target.    This is the most important event handler. It is responsible for modifying the   tree according to the drop operation. </p> </li> </ul> <pre><code>e = {\n  type: \"dnd.drop\",\n  node: // the target node\n  event: // &lt;the original HTML DragEvent&gt;\n  region: // 'before', 'after', 'over'\n  suggestedDropMode: // 'before', 'after', 'appendChild'\n                     // (compatible with node.moveTo() and .appendChild())\n  suggestedDropEffect: // 'copy', 'move', 'link'\n  sourceNode: // the source node if available\n  sourceNodeData: // the serialized data of the source node if any\n}\n</code></pre> <p>Foreign source data can be retreived from the <code>e.event.dataTransfer</code> object.</p> <ul> <li><code>dragEnd(e)</code>: Fired when a drag operation is ended.   We will hardly ever have to implement this handler.</li> </ul>"},{"location":"tutorial/tutorial_dnd/#related-tree-options","title":"Related Tree Options","text":"<p>See also</p> <p>See also the API Documentation for DnD options and the live demo.</p>"},{"location":"tutorial/tutorial_dnd/#examples","title":"Examples","text":""},{"location":"tutorial/tutorial_dnd/#basic-drag-and-drop","title":"Basic Drag and Drop","text":"<p>Allow sorting of plain nodes:</p> <pre><code>const tree = new Wunderbaum({\n  // --- Common Options ---\n  ...\n  dnd: {\n    dragStart: (e) =&gt; {\n      if (e.node.type === \"folder\") {\n        return false; // do not allow dragging folders\n      }\n      return true;\n    },\n    dragEnter: (e) =&gt; {\n      if (e.node.type === \"folder\") {\n        return \"over\";\n      }\n      return [\"before\", \"after\"];\n    },\n    drop: (e) =&gt; {\n      console.log(\n        `Drop ${e.sourceNode} =&gt; ${e.suggestedDropEffect} ${e.suggestedDropMode} ${e.node}`, e\n      );\n      e.sourceNode.moveTo(e.node, e.suggestedDropMode)\n    },\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_dnd/#basic-drag-and-drop-move","title":"Basic Drag and Drop (move)","text":"<pre><code>const tree = new Wunderbaum({\n  // --- Common Options ---\n  ...\n  dnd: {\n    effectAllowed: \"all\",\n    dropEffectDefault: \"move\",\n    guessDropEffect: true,\n    dragStart: (e) =&gt; {\n      // if (e.node.type === \"folder\") {\n      //   return false;\n      // }\n      return true;\n    },\n    dragEnter: (e) =&gt; {\n      // console.log(`DragEnter ${e.event.dataTransfer.dropEffect} ${e.node}`, e);\n      // We can only drop 'over' a folder, so the source node becomes a child.\n      // We can drop 'before' or 'after' a non-folder, so the source node becomes a sibling.\n      if (e.node.type === \"folder\") {\n        // e.event.dataTransfer.dropEffect = \"link\";\n        return \"over\";\n      }\n      return [\"before\", \"after\"];\n    },\n    drag: (e) =&gt; {\n      // e.tree.log(e.type, e);\n    },\n    drop: (e) =&gt; {\n      console.log(\n        `Drop ${e.sourceNode} =&gt; ${e.suggestedDropEffect} ${e.suggestedDropMode} ${e.node}`,\n        e\n      );\n      switch (e.suggestedDropEffect) {\n        case \"copy\":\n          e.node.addNode(\n            { title: `Copy of ${e.sourceNodeData.title}` },\n            e.suggestedDropMode\n          );\n          break;\n        case \"link\":\n          e.node.addNode(\n            { title: `Link to ${e.sourceNodeData.title}` },\n            e.suggestedDropMode\n          );\n          break;\n        default:\n          e.sourceNode.moveTo(e.node, e.suggestedDropMode);\n      }\n    },\n  },\n</code></pre>"},{"location":"tutorial/tutorial_dnd/#related-methods","title":"Related Methods","text":"<ul> <li><code>util.foo()</code></li> </ul>"},{"location":"tutorial/tutorial_dnd/#related-css-rules","title":"Related CSS Rules","text":"<pre><code>div.wb-row.wb-drag-source {\n  /* The dragged node */\n}\ndiv.wb-row.wb-drop-target {\n  /* The current target node while dragging */\n}\ndiv.wb-row.wb-drop-target.wb-drop-before .wb-node .wb-icon::after {\n  /* Drop marker */\n}\n</code></pre>"},{"location":"tutorial/tutorial_dnd/#code-hacks","title":"Code Hacks","text":""},{"location":"tutorial/tutorial_edit/","title":"Edit Nodes and Columns","text":"<p>TL;DR</p> <p>Wunderbaum implements renaming of nodes and editing grid cells.</p> <p>Editing is supported in two different ways:</p> <ol> <li> <p>There is direct support for renaming nodes, i.e. editing the node title.    Use the <code>edit.trigger</code> option and implement the <code>edit.apply()</code> callback    to enable this.</p> </li> <li> <p>In a treegrid, there is also general support for embedded input elements    in column cells, like checkboxes, text fields, etc.    Note that Wunderbaum does not implement fancy input controls though.    Rather think of it as a framework that makes it easy to use standard or    custom HTML controls:     Create HTML controls in the <code>tree.render()</code> callback and implement the    <code>tree.change()</code> event to enable this.</p> </li> </ol>"},{"location":"tutorial/tutorial_edit/#1-rename-nodes","title":"1. Rename Nodes","text":"<p>Here is an example implementation of the edit title feature (i.e. rename):</p> <pre><code>const tree = new Wunderbaum({\n  // --- Common Options ---\n  ...\n  // --- Common Events ---\n  ...\n  // --- Special Options and Events ---\n  edit: {\n    // --- Options ---\n    trigger: [\"clickActive\", \"F2\", \"macEnter\", ...],\n    select: true,  // Select all text on start\n    slowClickDelay: 1000,\n    trim: true,  // Trim input before applying\n    validity: true,  // Check validation rules while typing\n    ...\n    // --- Events ---\n    /**\n     * Called when an editing request was detected, e.g. `F2` key, etc.\n     *\n     * Return `false` to prevent editing. Optionally an HTML string may be\n     * returned that defines the temporary input element.\n     * Any other return value - including undefined - defaults to\n     * `'&lt;input type=\"text\" class=\"wb-input-edit\" value=\"TITLE\" required autocorrect=\"off\"&gt;'`\n     */\n    beforeEdit: (e) =&gt; {\n    },\n    /**\n     * Called after the temporary input control was created, initialized\n     * with the current node title, focused, and selected.\n     */\n    edit: (e) =&gt; {\n      const inputElem = e.inputElem;\n    },\n    /**\n     * Called when the edit operation is ending, either because the user\n     * canceled, confirmed, or moved focus.\n     *\n     * Return `false` to keep the input control open (not always possible).\n     *\n     * We can also return a `Promise` (e.g. from an Ajax request).\n     * In this case, the cell is marked 'busy' while the request is pending.\n     *\n     * Implementing this event is optional. By default, `node.setTitle()` is\n     * called with the new text.\n     */\n    apply: (e) =&gt; {\n      const node = e.node;\n      const oldValue = e.oldValue;\n      const newValue = e.newValue;\n      const inputElem = e.inputElem;\n      // For example:\n      // call an async storage function and  handle validation.\n      //\n      return storeMyStuff(node.refKey, newValue).then(() =&gt; {\n        if( ...) {\n          inputElem.setCustomValidity(`Invalid for *reasons*: ${newValue`})\n          return false;\n        }\n      };\n    },\n  },\n});\n</code></pre> <p>Input validation can be implemented by using the <code>inputElem.setCustomValidity()</code> method as in the example above, or by raising a util.ValidationError:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  edit: {\n    ...\n    apply: (e) =&gt; {\n      const util = e.util;\n      const node = e.node;\n      const newValue = e.newValue;\n\n      return storeMyStuff(node.refKey, newValue).then(() =&gt; {\n        if( ...) {\n          throw new util.ValidationError(`Invalid for *reasons*: ${newValue`});\n        }\n      };\n    },\n  },\n});\n</code></pre> <p>See also</p> <p>See also a live demo, activate a node, and hit <code>F2</code>.</p> <p>See also EditOptionsType.</p>"},{"location":"tutorial/tutorial_edit/#related-methods","title":"Related Methods","text":"<ul> <li><code>node.setActive(true, {colIdx: 0, edit: true})</code></li> <li><code>node.startEditTitle()</code></li> <li><code>tree.isEditingTitle()</code></li> <li><code>tree.startEditTitle(node)</code></li> <li><code>tree.stopEditTitle(apply: boolean)</code></li> <li><code>util.setValueToElem()</code></li> </ul>"},{"location":"tutorial/tutorial_edit/#style-hacks","title":"Style Hacks","text":"<pre><code>input.wb-input-edit {}\nspan.wb-col.wb-busy {}\nspan.wb-col.wb-error {}\nspan.wb-col.wb-invalid {}\nspan.wb-col input:invalid {}\nwb-tristate\n</code></pre>"},{"location":"tutorial/tutorial_edit/#code-hacks","title":"Code Hacks","text":"<pre><code>Todo;\n</code></pre>"},{"location":"tutorial/tutorial_edit/#2-edit-cell-content","title":"2. Edit Cell Content","text":"<p>See also</p> <p>See the Grid Tutorial for general information about rendering grid cell content.</p> <p>See also a live demo, expand some nodes and enter values into the input controls.</p> <p>Editing cells \u2014 other than the node title column \u2014 is not supported by default. Instead we have to</p> <ol> <li>Implement the <code>render(e)</code> callback to render the cell's content as an HTML    element that can be edited, like a text field, checkbox, etc.</li> <li>Implement the <code>change(e)</code> callback to update the node data when the user    has finished editing a cell.</li> </ol>"},{"location":"tutorial/tutorial_edit/#21-render-input-elements","title":"2.1. Render Input Elements","text":"<p>Following an example implementation of the <code>render(e)</code> callback that renders embedded input controls for all data columns.</p> <p>The util.setValueToElem() helper function can be used to update the embedded input element with the current node value.</p> <p>The <code>e.isNew</code> property is <code>true</code> if the node is new and has not been rendered before. This is useful to avoid overwriting user input when the user is editing a cell.</p> <p>We follow the convention to name the column id after the node data property that should be rendered in that column for simplicity.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  columns: [\n    { title: \"Title\", id: \"*\", width: \"250px\" },\n    { title: \"Age\", id: \"age\", width: \"50px\", classes: \"wb-helper-end\" },\n    { title: \"Date\", id: \"date\", width: \"100px\", classes: \"wb-helper-end\" },\n    { title: \"Status\", id: \"state\", width: \"70px\", classes: \"wb-helper-center\" },\n    { title: \"Avail.\", id: \"avail\", width: \"70px\", classes: \"wb-helper-center\" },\n    { title: \"Remarks\", id: \"remarks\", width: \"*\" },\n  ],\n\n  render: function (e) {\n    const node = e.node;\n    const util = e.util;\n\n    // Render embedded input controls for all data columns\n    for (const col of Object.values(e.renderColInfosById)) {\n\n      const val = node.data[col.id];\n\n      switch (col.id) {\n        case \"author\":\n          if (e.isNew) {\n            col.elem.innerHTML = '&lt;input type=\"text\" tabindex=\"-1\"&gt;';\n          }\n          util.setValueToElem(col.elem, val);\n          break;\n        case \"remarks\":\n          if (e.isNew) {\n            col.elem.innerHTML = '&lt;input type=\"text\" tabindex=\"-1\"&gt;';\n          }\n          util.setValueToElem(col.elem, val);\n          break;\n        case \"age\": // numeric input (positive integers only)\n          if (e.isNew) {\n            col.elem.innerHTML = '&lt;input type=\"number\" min=\"0\" tabindex=\"-1\"&gt;';\n          }\n          util.setValueToElem(col.elem, val);\n          break;\n        case \"state\": // select box\n          if (e.isNew) {\n            col.elem.innerHTML = `&lt;select tabindex=\"-1\"&gt;\n                &lt;option value=\"h\"&gt;Happy&lt;/option&gt;\n                &lt;option value=\"s\"&gt;Sad&lt;/option&gt;\n                &lt;/select&gt;`;\n          }\n          util.setValueToElem(col.elem, val);\n          break;\n        case \"avail\": // checkbox\n          if (e.isNew) {\n            col.elem.innerHTML = '&lt;input type=\"checkbox\" tabindex=\"-1\"&gt;';\n          }\n          util.setValueToElem(col.elem, val);\n          break;\n        case \"date\": // date picker\n          if (e.isNew) {\n            col.elem.innerHTML = '&lt;input type=\"date\" tabindex=\"-1\"&gt;';\n          }\n          util.setValueToElem(col.elem, val);\n          break;\n        default:\n          // Render all other node data cells as text (read-only)\n          // Assumption: we named column.id === node.data.NAME\n          col.elem.textContent = node.data[col.id];\n          break;\n      }\n    },\n});\n</code></pre>"},{"location":"tutorial/tutorial_edit/#simplify-the-pattern","title":"Simplify the Pattern","text":"<p>The pattern above can be simplified by defining the <code>html</code> property in the column definition, so the column cells are rendered by default and we can skip the <code>if (e.isNew) {...}</code> handling.  Note that we still have to update the embedded input elements with the current node value.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  columns: [\n    { title: \"Title\", id: \"*\", width: \"250px\" },\n    { title: \"Age\", id: \"age\", width: \"50px\", classes: \"wb-helper-end\",\n      \"html\": \"&lt;input type=number min=0 tabindex='-1'&gt;\",\n    },\n    { title: \"Date\", id: \"date\", width: \"100px\", classes: \"wb-helper-end\",\n      \"html\": '&lt;input type=date tabindex=\"-1\"&gt;',\n    },\n    { title: \"Status\", id: \"state\", width: \"70px\", classes: \"wb-helper-center\",\n      \"html\": `&lt;select tabindex=\"-1\"&gt;\n          &lt;option value=\"h\"&gt;Happy&lt;/option&gt;\n          &lt;option value=\"s\"&gt;Sad&lt;/option&gt;\n          &lt;/select&gt;`\n    },\n    { title: \"Avail.\", id: \"avail\", width: \"70px\", classes: \"wb-helper-center\",\n      \"html\": '&lt;input type=checkbox tabindex=\"-1\"&gt;',\n    },\n    { title: \"Remarks\", id: \"remarks\", width: \"*\",\n      \"html\": \"&lt;input type=text tabindex='-1'&gt;\",\n    },\n  ],\n\n  render: function (e) {\n    const node = e.node;\n    const util = e.util;\n\n    // Render embedded input controls for all data columns\n    for (const col of Object.values(e.renderColInfosById)) {\n\n      const val = node.data[col.id];\n\n      switch (col.id) {\n        default:\n          util.setValueToElem(col.elem, val);\n          break;\n      }\n    }\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_edit/#22-validate-and-apply-modified-cell-data","title":"2.2. Validate and Apply Modified Cell Data","text":"<p>The <code>change(e)</code> callback is called when the user has finished editing a cell. More precisely, it is called when the embedded input, select, or textarea element fired a change event.  It receives a WbChangeEventType object that contains useful properties for this purpose.</p> <p>The util.getValueFromElem() helper function can be used to read the current value from the embedded input element. This value is also avalable as <code>e.inputValue</code>, however without coercing date inputs to Date instances.</p> <p>Again, we follow the convention to name the column id after the node data property that appears in that column.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  change: function (e) {\n    const util = e.util;\n    const node = e.node;\n    const colId = e.info.colId;\n\n    this.logDebug(`change(${colId})`, util.getValueFromElem(e.inputElem, true));\n\n    // Assumption: we named column.id === node.data.NAME\n    node.data[colId] = util.getValueFromElem(e.inputElem, true);\n  },\n});\n</code></pre> <p>If we want to customize the <code>change(e)</code> callback, we can do so like this:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  change: function (e) {\n    const util = e.util;\n    const node = e.node;\n    const colId = e.info.colId;\n    let val;\n\n    switch (colId) {\n      case \"year\":\n        val = util.getValueFromElem(e.inputElem, true);\n\n        if(val &amp;&amp; new Date(val) &gt; new Date()) {\n          throw new util.ValidationError(\"Invalid year (must not be in the past)\");\n        }\n        if (val &amp;&amp; !/^\\d{4}$/.test(val)) {\n          throw new util.ValidationError(\"Invalid year (yyyy)\");\n        }\n        e.node.data[colId] = val;\n        break;\n      default:\n        e.node.data[colId] = util.getValueFromElem(e.inputElem, true);\n        break;\n    }\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_edit/#related-methods_1","title":"Related Methods","text":"<ul> <li><code>node.setActive(true, {colIdx: 2, edit: true})</code></li> <li><code>util.getValueFromElem()</code></li> <li><code>util.setValueToElem()</code></li> <li><code>util.toggleCheckbox()</code></li> </ul>"},{"location":"tutorial/tutorial_edit/#related-css-rules","title":"Related CSS Rules","text":"<pre><code>span.wb-col.wb-busy {\n}\nspan.wb-col.wb-error {\n}\nspan.wb-col input:invalid {\n}\n</code></pre>"},{"location":"tutorial/tutorial_events/","title":"Event Handling","text":"<p>TL;DR</p> <p>The interactive behavior of Wunderbaum is controlled by a set of event handlers.</p> <p>Event handlers are callback functions that are passes as options of the tree object, and are called whenever a certain event occurs:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  id: \"demo\",\n  element: document.getElementById(\"demo-tree\"),\n  source: \"get/root/nodes\",\n  ...\n  init: (e) =&gt; {\n    e.tree.setFocus();\n  },\n  lazyLoad: function (e) {\n    return { url: 'get/child/nodes', params: { parentKey: e.node.key } };\n  },\n  activate: function (e) {\n    alert(`Thank you for activating ${e.node}.`);\n  },\n  ...\n});\n</code></pre>"},{"location":"tutorial/tutorial_events/#the-event-object","title":"The Event Object","text":"<p>Depending on the event type, the event handler functions can return a value, that is used by the tree to control the default behavior. For example, the <code>beforeActivate</code> event handler can return <code>false</code> to prevent activation of a node.</p> <p>Some events are sent by the tree, others by a distinct node. A node event always passes a reference to the node object. A tree event does not always pass a node reference.</p> <p>The event handler functions are called with a single argument, of type WbTreeEventType.</p> <p>The event object contains the following properties:</p> <pre><code>e = {\n  type: string,         // the event type\n  tree: Wunderbaum,     // the tree object\n  util: object,         // some useful utility functions\n  node: WunderbaumNode, // the node object (if applicable)\n  event: Event,         // the original DOM event (if applicable)\n  flag: boolean,        // a flag (if applicable)\n  error: string,        // an error (if applicable)\n  ...                   // additional properties (if applicable)\n}\n</code></pre> <p>See also</p> <p>See also the overview of available functions of the utility module.</p>"},{"location":"tutorial/tutorial_events/#event-handlers","title":"Event Handlers","text":"<p>Info</p> <p>A list of all available events can also be found in the API Reference.</p> <p>Common event handlers include:</p> <code>activate(WbActivateEventType)</code> - node event    `e.node` was activated.  <code>beforeActivate(WbActivateEventType)</code> - node event    Return `false` to prevent activation of `e.node`.  <code>beforeExpand(WbExpandEventType)</code> - node event    Return `false` to prevent expansion of `e.node`.  <code>beforeSelect(WbSelectEventType)</code> - node event    Return `false` to prevent (de)selection.  <code>buttonClick(WbButtonClickEventType)</code> - tree event    A column header button was clicked, e.g. sort, filter, or menu.   Check `e.command` and `e.info.colId`, ... for details.    Note that the actual implementation of the command must be explicitly provided.   See also Search and Filter for examples.   <code>change(WbChangeEventType)</code> - node event    The `change(e)` callback is called when the user has finished editing a cell.   More precisely, it is called when the embedded input, select,   or textarea element fired a change event.  <code>click(WbClickEventType)</code> - node event    `e.node` was clicked.    Return `false` to prevent default behavior, e.g. expand/collapse,   (de)selection, or activation.  <code>dblclick(WbClickEventType)</code> - node event    `e.node` was double-clicked.    Return `false` to prevent default behavior, e.g. expand/collapse.  <code>deactivate(WbDeactivateEventType)</code> - node event    `e.node` was deactivated.  <code>discard(WbNodeEventType)</code> - node event    `e.node` was discarded from the viewport and its HTML markup removed.  <code>edit.apply(WbEditApplyEventType)</code> - node event    `e.node` title was changed.  <code>edit.beforeEdit(WbNodeEventType)</code> - node event    `e.node` title is about to renamend. Return `false` to prevent renaming.  <code>edit.edit(WbEditEditEventType)</code> - node event    `e.node` just switched to edit mode, an input element was created and populated with the current title.  <code>error(WbErrorEventType)</code> - node event    An error occurred, e.g. during initialization or lazy loading.  <code>expand(WbExpandEventType)</code> - node event    `e.node` was expanded (`e.flag === true`) or collapsed (`e.flag === false`)  <code>focus(WbFocusEventType)</code> - tree event    The tree received or lost focus. Check `e.flag`.  <code>iconBadge(WbIconBadgeEventType)</code> - node event    `e.node` is about to be rendered. We can add a badge to the icon cell here.    Returns WbIconBadgeEventResultType.  <code>init(WbInitEventType)</code> - tree event    Fires when the tree markup was created and the initial source data was loaded.   Typical use cases would be activating a node, setting focus, enabling other   controls on the page, etc.   Also sent if an error occured during initialization (check for `e.error` property).  <code>keydown(WbKeydownEventType)</code> - tree event    Fires when a key was pressed while the tree has focus.    `e.node` is set if a node is currently active.    Return `false` to prevent default navigation.  <code>lazyLoad(WbNodeEventType)</code> - node event    Fires when a node that was marked 'lazy', is expanded for the first time.   Typically we return an endpoint URL or the Promise of a fetch request that   provides a (potentially nested) list of child nodes.  <code>load(WbNodeEventType)</code> - node event    Fires when data was loaded (initial request, reload, or lazy loading),   after the data is applied and rendered.  <code>modifyChild(WbModifyChildEventType)</code> - node event    TODO  <code>receive(WbReceiveEventType)</code> - node event    Fires when data was fetched (initial request, reload, or lazy loading),   but before the data is uncompressed, applied, and rendered.   Here we can modify and adjust the received data, for example to convert an   external response to native Wunderbaum syntax.  <code>render(WbRenderEventType)</code> - node event    Fires when a node is about to be displayed.   The default HTML markup is already created, but not yet added to the DOM.   Now we can tweak the markup, create HTML elements in this node's column   cells, etc.    See also `Custom Rendering` for details.  <code>renderStatusNode(WbRenderEventType)</code> - node event    Same as `render(e)`, but for the status nodes, i.e. `e.node.statusNodeType`.  <code>select(WbSelectEventType)</code> - node event    `e.node` was selected (`e.flag === true`) or deselected (`e.flag === false`)  <code>update(WbRenderEventType)</code> - tree event    Fires when the viewport was updated, after scroling, expanding etc."},{"location":"tutorial/tutorial_events/#register-custom-events","title":"Register Custom events","text":"<p>To register a custom event, we can use event delegation. For example, to handle a <code>contextmenu</code> event on a row, we can add an event listener to the <code>body</code> element. This would allow to prevent the default context menu, or to show a custom context menu.  The <code>getNode()</code> utility method can be used to retrieve the node object that corresponds to the clicked row:</p> <pre><code>&lt;script&gt;\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    document.body.addEventListener(\"contextmenu\", function (event) {\n      if (event.target.closest(\"div.wb-row\")) {\n        const node = mar10.Wunderbaum.getNode(event);\n        node.logInfo(\"received contextmenu event\");\n\n        // Optionally prevent the default context menu:\n        event.preventDefault();\n      }\n    });\n  });\n&lt;/script&gt;\n</code></pre>"},{"location":"tutorial/tutorial_filter/","title":"Search and Filter Nodes","text":"<p>TL;DR</p> <p>Wunderbaum supports different ways to search and filter nodes.</p> <p>This page describes how searching and filtering can be enabled:</p> <ol> <li> <p>Search allows to find nodes by title patterns or arbitrary conditions.</p> </li> <li> <p>Filter is a more powerful feature that can hide or dim nodes that do not    match a given search pattern or condition. It can also highlight matching    title parts.</p> </li> </ol>"},{"location":"tutorial/tutorial_filter/#searching","title":"Searching","text":""},{"location":"tutorial/tutorial_filter/#quicksearch","title":"Quicksearch","text":"<p>Quicksearch is triggered by typing a character and jumps to the next node that starts with that character.  It can be disabled by setting <code>quicksearch: false</code> in the tree options.</p>"},{"location":"tutorial/tutorial_filter/#using-the-api","title":"Using the API","text":"<p>Many methods are available to search for nodes. For example, to find a node by its title, use <code>tree.findFirst()</code>, <code>tree.findAll()</code> and others:</p> <pre><code>// Match all node titles that match exactly 'Joe':\nnodeList = node.findAll(\"Joe\");\n// Match all node titles that start with 'Joe' case sensitive:\nnodeList = node.findAll(/^Joe/);\n// Match all node titles that contain 'oe', case insensitive:\nnodeList = node.findAll(/oe/i);\n// Match all nodes with `data.price` &gt;= 99:\nnodeList = node.findAll((n) =&gt; {\n  return n.data.price &gt;= 99;\n});\n</code></pre> <p>See also</p> <p>See also the API tutorial for more details.</p>"},{"location":"tutorial/tutorial_filter/#filtering","title":"Filtering","text":"<p>A filter can be used to hide or dim nodes that do not match a given search pattern.</p> <p>First, define the filter options in the tree options:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  filter: {\n    autoApply: true, // Re-apply last filter if lazy data is loaded\n    mode: \"hide\",\n    ...\n  },\n  ...\n});\n</code></pre> <p>Following options are available (see also FilterOptionsType):</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  filter: {\n    autoApply: true, // Re-apply last filter if lazy data is loaded\n    autoExpand: false, // Expand all branches that contain matches while filtered\n    matchBranch: false, // Whether to implicitly match all children of matched nodes\n    connect: null, // Element or selector of an input control for filter query strings\n    fuzzy: false, // Match single characters in order, e.g. 'fb' will match 'FooBar'\n    hideExpanders: false, // Hide expanders if all child nodes are hidden by filter\n    highlight: true, // Highlight matches by wrapping inside &lt;mark&gt; tags\n    leavesOnly: false, // Match end nodes only\n    mode: \"dim\", // Grayout unmatched nodes (pass \"hide\" to remove unmatched node instead)\n    noData: true, // Display a 'no data' status node if result is empty\n  },\n  ...\n});\n</code></pre>"},{"location":"tutorial/tutorial_filter/#filter-nodes","title":"Filter Nodes","text":"<p>The <code>filterNodes()</code> method can be used to apply a filter to the tree. It accepts a string, a regular expression, or a function as a filter pattern:</p> <pre><code>// Strings are matched against the node titles (contains, case insensitive)\ntree.filterNodes(\"Joe\");\n// Regular expressions are matched against the node titles\n// E.g. fin titles that start with 'joe' or 'joh' (case insensitive)\ntree.filterNodes(/^jo[eh]/i);\n// Functions are called with the node as an argument and can test for any\n// condition\ntree.filterNodes((node) =&gt; {\n  return node.data.price &gt;= 99;\n});\n</code></pre> <p>Additional options can be passed as a second argument to override the default <code>tree.filter</code> settings:</p> <pre><code>tree.filterNodes(\"Joe\", { mode: \"hide\" });\n</code></pre> <p>See FilterNodesOptions):</p> <p>Examples</p> <pre><code>// Match all nodes with a title that does contain 'Joe' (case insensitive) and\n// dim the rest:\ntree.filterNodes(\"Joe\");\n// Match all nodes with a title that does contain 'Joe' (case insensitive) and\n// hide the rest:\ntree.filterNodes(\"Joe\", { mode: \"hide\" });\n// Match all nodes with a custom property 'age' &gt; 30:\ntree.filterNodes((node) =&gt; {\n  return node.data.age &lt;= 30;\n});\n// Match  all nodes with a a title that contains 'foo' or 'fox':\nconst re = /.*fo[ox].*/i;\ntree.filterNodes((node) =&gt; {\n  return re.test(node.title);\n});\n</code></pre> <p>Info</p> <p>A filter callback may return a boolean value, or the string values 'skip' or 'branch'. The latter will skip or match the node and all its descendants.  Note that highlighting matches is not supported for function filters.</p>"},{"location":"tutorial/tutorial_filter/#display-count-of-matches-as-badges","title":"Display Count of Matches as Badges","text":"<p>Show a badge with number of matching child nodes near parent icons. If no matchin children exist or the node is expanded, the badge is hidden.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  iconBadge: (e) =&gt; {\n    const node = e.node;\n    if (node.children?.length &gt; 0 &amp;&amp; !node.expanded &amp;&amp; node.subMatchCount &gt; 0) {\n      return {\n        badge: node.subMatchCount,\n        badgeTooltip: `${node.subMatchCount} matches`,\n        badgeClass: \"match-count\",\n      };\n    }\n  },\n  ...\n});\n</code></pre>"},{"location":"tutorial/tutorial_filter/#connect-to-search-input","title":"Connect to Search Input","text":"<p>Define some html elements as filter controls:</p> <pre><code>&lt;label for=\"filter-query\"&gt;Filter:&lt;/label&gt;\n&lt;input\n  id=\"filter-query\"\n  type=\"search\"\n  placeholder=\"Enter search pattern\"\n  autofocus\n/&gt;\n&lt;button type=\"button\" title=\"Hide unmatched nodes\"&gt;\n  &lt;i class=\"bi bi-funnel\"&gt;&lt;/i&gt;\n&lt;/button&gt;\n</code></pre> <p>and connect them to the <code>tree.filterNodes()</code> method:</p> <pre><code>const queryInput = document.querySelector(\"input#filter-query\");\n\nqueryInput.addEventListener(\n  \"input\",\n  Wunderbaum.util.debounce((e) =&gt; {\n    tree.filterNodes(queryInput.value.trim(), {});\n  }, 700)\n);\n...\n// For example: dynamically toggle hide/dim mode\ntree.setOption(\"filter.mode\", hideMode ? \"hide\" : \"dim\");\n</code></pre> <p>An even simpler way is to use the <code>options.filter.connect</code> option, like in the demo.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  filter: {\n      mode: \"hide\",\n      autoExpand: true,\n      connect: {\n          inputElem: \"#filter-query\",\n          modeButton: \"#filter-hide\",\n          nextButton: \"#filter-next\",\n          prevButton: \"#filter-prev\",\n          matchInfoElem: \"#filter-match-info\",\n      }\n  },\n});\n</code></pre> <p>See also</p> <p>See also a live demo and enter some text in the Filter control at the top.</p>"},{"location":"tutorial/tutorial_filter/#add-a-filter-button-to-the-column-header","title":"Add a Filter Button to the Column Header","text":"<p>Add a filter button to the column header to toggle the filter mode:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  columns: [\n    {\n      title: \"Title\",\n      filterable: true,\n    },\n    ...\n  ],\n  buttonClick: (e) =&gt; {\n    tree.log(e.type, e);\n\n    if (e.command === \"filter\") {\n\n      // ... &lt;open a filter dialog or toggle the filter mode&gt; ...\n\n      // Update the button state\n      e.info.colDef.filterActive = !e.info.colDef.filterActive;\n      tree.update(\"colStructure\");\n    }\n  },\n  ...\n});\n</code></pre>"},{"location":"tutorial/tutorial_filter/#related-methods","title":"Related Methods","text":"<ul> <li><code>tree.clearFilter()</code></li> <li><code>tree.countMatches()</code></li> <li><code>tree.filterNodes()</code></li> <li><code>tree.findAll()</code></li> <li><code>tree.findFirst()</code></li> <li><code>tree.iconBadge()</code></li> <li><code>tree.isFilterActive()</code></li> <li><code>tree.updateFilter()</code></li> </ul>"},{"location":"tutorial/tutorial_filter/#related-css-rules","title":"Related CSS Rules","text":"<pre><code>&amp;.wb-ext-filter-dim,\n&amp;.wb-ext-filter-hide {\n  div.wb-node-list div.wb-row {\n    color: $filter-dim-color;\n\n    &amp;.wb-submatch {\n      color: $filter-submatch-color;\n    }\n\n    &amp;.wb-match {\n      color: $node-text-color;\n    }\n  }\n}\n</code></pre>"},{"location":"tutorial/tutorial_grid/","title":"Grid","text":"<p>TL;DR</p> <p>Wunderbaum implements native support for treegrids (in fact, a plain tree is only a special case).  Rendering and editing of grid cells requires custom event handlers.</p> <p>See also</p> <p>See also a live demo.</p> <p>Wunderbaum works as a treegrid out of the box if we specify column definitions.  In a treegrid, there is also general support for embedded input elements in column cells, like checkboxes, text fields, etc.</p> <p>Note that the treegrid is not editable by default however. It does not even render cell content for columns other than the main (first) node column. This has to be implemented in the <code>render(e)</code> callback instead.  Wunderbaum does not implement fancy input controls. Rather think of it as a framework that makes it easy to use standard or custom HTML controls:  Create HTML controls in the <code>render(e)</code> callback and implement the <code>change(e)</code> event to enable editing.</p>"},{"location":"tutorial/tutorial_grid/#column-definitions","title":"Column Definitions","text":"<p>Info</p> <p>Column definitions are required to turn a plain Wunderbaum tree into a treegrid.</p> <p>A list of column definitions is specified in the <code>columns</code> option. <code>title</code> and <code>id</code> are required. <code>width</code> is optional, but recommended.</p> <p>The <code>id</code> is used to identify the column in the <code>render</code> event.  The special id <code>\"*\"</code> is used for the main node column with checkbox, connectors, icon, and title). It is required and must be the first column in the list.</p> <p>The <code>width</code> is either specified in absolute pixels (<code>\"100px\"</code>) or relative weights (<code>\"2.5\"</code>). Column widths default to <code>\"*\"</code>, which is equivalent to <code>\"1.0\"</code>  Absolute widths are applied first, then the remaining space is distributed among the relative weights.</p> <p>The <code>classes</code> property can be used to add CSS classes to the column header and cells.</p> <p>The <code>html</code> property can be used to define cell markup that is rendered by default.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  columns: [\n    { id: \"*\", title: \"Product\", width: \"250px\" },\n    { id: \"author\", title: \"Author\", width: \"200px\" },\n    { id: \"year\", title: \"Year\", width: \"50px\", classes: \"wb-helper-end\" },\n    { id: \"qty\", title: \"Qty\", width: \"50px\", classes: \"wb-helper-end\" },\n    {\n      id: \"price\",\n      title: \"Price ($)\",\n      width: \"80px\",\n      classes: \"wb-helper-end\",  // (1)\n    },\n    { id: \"details\", title: \"Details\", width: \"*\" },\n  ],\n  ...\n});\n</code></pre> <ol> <li>This classes are added to all header and row cells of that column.     In this case: right align the content of the column.</li> </ol> <p>Info</p> <p>See also ColumnDefinition for details.</p>"},{"location":"tutorial/tutorial_grid/#rendering","title":"Rendering","text":"<p>Wunderbaum renders the first column (the main node column) by default. To render additional columns, implement the <code>render(e)</code> callback.</p> <p>The render event receives a WbRenderEventType object that contains useful properties for this purpose.</p> <p>We can use the <code>e.renderColInfosById</code> property to iterate over all columns and render the content of each column.  This can be simplified by following the convention to name the column id after the node data property that should be rendered in that column.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  types: {},\n  columns: [\n    { id: \"*\", title: \"Product\", width: \"250px\" },\n    { id: \"author\", title: \"Author\", width: \"200px\" },\n    { id: \"year\", title: \"Year\", width: \"50px\", classes: \"wb-helper-end\" },\n    { id: \"qty\", title: \"Qty\", width: \"50px\", classes: \"wb-helper-end\" },\n    {\n      id: \"price\",\n      title: \"Price ($)\",\n      width: \"80px\",\n      classes: \"wb-helper-end\",\n    },\n    { id: \"details\", title: \"Details\", width: \"*\" },\n  ],\n  ...\n  render: function (e) {\n    const node = e.node;\n\n    for (const col of Object.values(e.renderColInfosById)) {\n      switch (col.id) {\n        default:\n          // Assumption: we named column.id === node.data.NAME\n          col.elem.textContent = node.data[col.id];\n          break;\n      }\n    }\n  },\n});\n</code></pre> <p>If we want to render formatted values, we can do this explicitly for each column:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  render: function (e) {\n    const node = e.node;\n\n    for (const col of Object.values(e.renderColInfosById)) {\n      const val = node.data[col.id];\n\n      switch (col.id) {\n        case \"date\":\n          if (val) {\n            const dt = new Date(val);\n            col.elem.textContent = dt.toISOString().slice(0, 10);\n          } else {\n            col.elem.textContent = \"n.a.\";\n          }\n          break;\n        case \"state\":\n          {\n            const map = { h: \"Happy\", s: \"Sad\" };\n            col.elem.textContent = map[val] || \"n.a.\";\n          }\n          break;\n        case \"avail\":\n          col.elem.textContent = val ? \"Yes\" : \"No\";\n          break;\n        default:\n          // Assumption: we named column.id === node.data.NAME\n          col.elem.textContent = val;\n          break;\n      }\n    }\n  },\n});\n</code></pre> <p>Info</p> <p>See the Edit Tutorial for examples how to render embedded controls.</p>"},{"location":"tutorial/tutorial_grid/#editing","title":"Editing","text":"<p>Editing cells \u2014 other than the node title column \u2014 is not supported by default. Instead we have to</p> <ol> <li>Implement the <code>render(e)</code> callback to render the cell's content as an HTML    element that can be edited, like a text field, checkbox, etc.</li> <li>Implement the <code>change(e)</code> callback to update the node data when the user    has finished editing a cell.</li> </ol> <p>Info</p> <p>See the Edit Tutorial for details.</p>"},{"location":"tutorial/tutorial_grid/#navigation","title":"Navigation","text":"<p>A treegrid can have one of two navigation modes. We can toggle using the keyboard:</p> <p>Row Mode \u2194 Cell-Nav Mode</p> <p>Info</p> <p>See the Keyboard Tutorial for details.</p>"},{"location":"tutorial/tutorial_grid/#configuration-and-customization","title":"Configuration and Customization","text":"<p>Note</p> <p>Todo.</p>"},{"location":"tutorial/tutorial_grid/#related-tree-options","title":"Related Tree Options","text":"<pre><code>const tree = new Wunderbaum({\n  ...\n  navigationModeOption: \"startRow\",  // | \"cell\" | \"startCell\" | \"row\"\n  columns: [],\n  ...\n  // --- Events ---\n  render: (e) =&gt; {\n    // Return false to prevent default behavior\n  }\n  ...\n  edit: {\n    trigger: [\"F2\", \"macEnter\", ...],\n    ...\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_grid/#related-methods","title":"Related Methods","text":"<ul> <li><code>tree.setNavigationOption(mode: NavModeEnum)</code></li> <li><code>tree.setColumn(colIdx: number|string,  options?: SetColumnOptions)</code></li> </ul>"},{"location":"tutorial/tutorial_grid/#related-css-rules","title":"Related CSS Rules","text":""},{"location":"tutorial/tutorial_grid/#code-hacks","title":"Code Hacks","text":""},{"location":"tutorial/tutorial_grid/#redefine-columns","title":"Redefine Columns","text":"<p>For example to append a new column:</p> <pre><code>tree.columns.push({\n  title: \"New Col\",\n  id: \"col_\" + sequence++,\n  width: \"100px\",\n});\ntree.update(\"colStructure\");\n</code></pre>"},{"location":"tutorial/tutorial_grid/#add-a-menu-button-to-the-column-header","title":"Add a Menu Button to the Column Header","text":"<p>Add a filter button to the column header to toggle the filter mode:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  columns: [\n    {\n      title: \"Title\",\n      menu: true,\n      ...\n    },\n    ...\n  ],\n  buttonClick: (e) =&gt; {\n    if (e.command === \"menu\") {\n      alert(\"Open menu...\");\n    }\n  },\n  ...\n});\n</code></pre>"},{"location":"tutorial/tutorial_grid/#add-a-sort-button-to-the-column-header","title":"Add a Sort Button to the Column Header","text":"<p>Add a sort button to the column header and handle click events to toggle the order:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  columns: [\n    {\n      title: \"Title\",\n      sortable: true, // or set in column definition\n      ...\n    },\n    ...\n  ],\n  columnsSortable: true, // or set in column definition\n  buttonClick: (e) =&gt; {\n    if (e.command === \"sort\") {\n      e.tree.sortByProperty({ colId: e.info.colId, updateColInfo: true });\n    }\n  },\n  ...\n});\n</code></pre>"},{"location":"tutorial/tutorial_initialize/","title":"Loading and Initialization","text":"<p>TL;DR</p> <p>Wunderbaum is included on a page and initialized by instantiating a Wunderbaum object with custom options.</p>"},{"location":"tutorial/tutorial_initialize/#preparation","title":"Preparation","text":"<p>We need to include the library, stylesheets, and fonts as a precondition.  See Quick Start for details.</p>"},{"location":"tutorial/tutorial_initialize/#passing-options","title":"Passing Options","text":"<p>There are many more options and callbacks available. Here are some of the frequently used ones:</p> <pre><code>document.addEventListener(\"DOMContentLoaded\", (event) =&gt; {\n  const tree = new mar10.Wunderbaum({\n    element: document.getElementById(\"demo-tree\"),\n    id: \"demo\",\n    types: {},\n    columns: [{ id: \"*\", title: \"Product\", width: \"250px\" }],\n    source: \"get/root/nodes\",\n    // Event handlers:\n    init: (e) =&gt; {\n      // e.tree.setFocus();\n      e.tree.findFirst(\"Foo\")?.setActive(true, {\n        colIdx: \"*\",\n        edit: true,\n        focusTree: true,\n      });\n    },\n    receive: function (e) {},\n    load: function (e) {},\n    lazyLoad: function (e) {\n      return { url: 'get/child/nodes', params: { parentKey: e.node.key } };\n    },\n    activate: function (e) {},\n    render: function (e) {},\n    ...\n  });\n});\n</code></pre> <p>Common options include:</p> element      Selector or HTML Element of the target div tag.  id      The identifier of this tree. Used to reference the instance, especially when     multiple trees are present (e.g. `tree = mar10.Wunderbaum.getTree(\"demo\")`).  source      Define the initial tree data. Typically a URL of an endpoint that serves a JSON formatted structure, but also a callback, Promise, or static data is allowed.  types      Define shared attributes for multiple nodes of the same `node.type`.     This allows for more compact data models.     Type definitions can be passed as tree option, or be part of a     `source` response.  columns      A list of maps that define column headers.     If this option is set, Wunderbaum becomes a treegrid control instead     of a plain tree.     Column definitions can be passed as tree option, or be part of a     `source` response.  <p>Info</p> <p>See WunderbaumOptions for a complete list of options.</p>"},{"location":"tutorial/tutorial_initialize/#dynamic-options","title":"Dynamic Options","text":"<p>Some node options can be defined in a flexible way, using a dynamic pattern.</p> <p>Consider for example the <code>checkbox</code> option, which may be true, false, or \"radio\". If omitted, it will default to false. Globally enabling checkboxes for all nodes can be configured like so:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  ...\n  checkbox: true,\n  ...\n</code></pre> <p>This global setting may be overridden per node by the concrete source data, if a property of the same name is present:</p> <pre><code>[\n  { title: \"Node 1\" },\n  { title: \"Node 2\", checkbox: false },\n  { title: \"Node 3\", checkbox: \"radio\" },\n];\n</code></pre> <p>If the global setting is a callback, it will be called for every node, thus allowing to dynamically define option values:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  checkbox: (e) =&gt; {\n    // Hide checkboxes for folders\n    return e.node.type === \"folder\" ? false : true;\n  },\n  tooltip: (e) =&gt; {\n    // Create dynamic tooltips\n    return `${e.node.title} (${e.node.key})`;\n  },\n  icon: (e) =&gt; {\n    // Create custom icons\n    if( e.node.data.critical ) {\n      return \"foo-icon-class\";\n    }\n    // Exit without returning a value: continue with default processing.\n  },\n  ...\n</code></pre> <p>Currently the following options are evaluated as dynamic options: <code>checkbox</code>, <code>icon</code>, <code>iconTooltip</code>, <code>tooltip</code>, <code>unselectable</code>.</p> <p>See method <code>node.getOption()</code> for details.</p>"},{"location":"tutorial/tutorial_initialize/#event-handlers","title":"Event Handlers","text":"<p>Event handlers can be used to control tree behavior and react on status changes. Common event handlers include: <code>init(e)</code>, <code>lazyLoad(e)</code>, <code>receive(e)</code>, <code>render(e)</code>, and more.</p> <p>Info</p> <p>Event Handlers are described in detail in the Events chapter.</p>"},{"location":"tutorial/tutorial_initialize/#data-source","title":"Data Source","text":"<p>Info</p> <p>See examples of JSON data and learn more in the next section, Data Formats</p> <p>Typically we load the tree nodes in a separate Ajax request like so:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  ...\n  source: \"path/to/request\",\n  ...\n});\n</code></pre> <p>The example above issues a simple GET request. For more controle, we can use the extended syntax:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  ...\n  source: {\n    url: \"path/to/request\",\n    params: {},  // key/value pairs converted to URL parameters\n    body: {},    // key/value pairs converted to JSON body (defaults to method POST)\n    options: {}, // passed to `fetch(url, OPTIONS)`\n  }\n  ...\n});\n</code></pre> <p>The endpoint must return a node structure in JSON format.</p> <p>Note that</p> <ul> <li>The structure may be nested, e.g. a child node may in turn contain a <code>children</code> list.</li> <li> <p>Some reserved attributes names are part of the node data model: <code>checkbox</code>, <code>classes</code>, <code>expanded</code>, <code>icon</code>, <code>iconTooltip</code>, <code>key</code>, <code>lazy</code>,   <code>radiogroup</code>, <code>refKey</code>, <code>selected</code>, <code>statusNodeType</code>, <code>title</code>, <code>tooltip</code>,   <code>type</code>, <code>unselectable</code>.   They can be accessed as <code>node.title</code>, for example,</p> </li> <li> <p>All other properties are stored under the data namespace and are accessed   like <code>node.data.author</code>, for example.</p> </li> <li>Only <code>title</code> is mandatory</li> <li>Node titles are escaped in order to prevent XSS.   For example if JSON source contains <code>\"title\": \"&lt;script&gt;...\"</code>, it will be   converted to <code>&amp;lt;script&amp;gt;...</code>, which is rendered by the browser as   <code>&lt;script&gt;...</code>, but not interpreted as HTML element.</li> </ul>"},{"location":"tutorial/tutorial_initialize/#handling-external-data-formats","title":"Handling External Data Formats","text":"<p>See also</p> <p>See also Example with source that queries the Fake Store API.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  source: { url: \"https://fakestoreapi.com/products/categories\" },\n  lazyLoad: (e) =&gt; {\n    return { url: `https://fakestoreapi.com/products/category/${e.node.refKey}` }\n  },\n  receive: (e) =&gt; {\n    return e.response.map((elem) =&gt; {\n      return {\n        title: elem.name,\n        refKey: elem.id,\n      }\n    });\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_keyboard/","title":"Keyboard Navigation","text":"<p>TL;DR</p> <p>Wunderbaum tree and treegrid is navigable using keyboard shortcuts. Different navigation modes are available.</p> <p>The option <code>keyboard: true</code> enables standard keyboard navigation.</p> <p>See also</p> <p>See also a live demo and use the keyboard to navigate, expand, and edit grid cells.</p>"},{"location":"tutorial/tutorial_keyboard/#general-keyboard-navigation","title":"General Keyboard Navigation","text":"<p>We distinguish node states 'focused', 'active', and 'selected'. <code>setFocus()</code> only sets a dotted border around the node. When <code>autoActivate</code> is enabled (which is on by default), the node also gets activated. A node becomes 'selected', when the checkbox is checked.</p> <p>A tree can have one of two navigation modes. We can toggle using the keyboard:</p> <p>Row Mode \u2194 Cell-Nav Mode</p> <p>The initial mode, and if modes can be switched, is controlled by the <code>navigationModeOption</code> option: If the tree has only one column, or if navigationModeOption is <code>\"row\"</code>, Row Mode is obligatory. If the value is <code>\"cell\"</code>, Cell-Nav Mode is obligatory. A value of <code>\"startCell\"</code> or <code>\"startRow\"</code> allows switching.</p>"},{"location":"tutorial/tutorial_keyboard/#navigation-in-row-mode","title":"Navigation in Row Mode","text":"<p>In row mode, Wunderbaum behaves like a simple tree. Even if multiple columns are present, always the whole row is highlighted.</p> Windows macOS Function AlphaNum Jump to next matching node, i.e. title starts with this character (if `quicksearch` is true). Tab, Shift + Tab Leave the Wunderbaum tree control and focus next/previous control on the page. + / - Expand/collapse node Space Toggle selected status if checkbox option is on. F2 Edit node title. Enter        If node is active and expandable: toggle expansion. Note:       Behaves as alias for F2 on macOS if edit.trigger option list       contains \"macEnter\". Escape Discard edit title operation if any. Backspace Set focus to parent node. ArrowLeft        If expanded: collapse. Otherwise set focus to parent node.      ArrowRight        If collapsed: expand.        Otherwise switch to \u2192Cell-Nav Mode.      ArrowUp Set focus to previous sibling (or parent if already on first sibling). ArrowDown Set focus to next visible node. Ctrl + Arrow\u2026 \u2318 + Arrow\u2026        Same as plain Arrow\u2026, but only sets the focus, even if       autoActivate option is on.      Home Fn + ArrowLeft        \u2014      End Fn + ArrowRight        \u2014      PageUp Fn + ArrowUp        Select top row in viewport or scroll one page upwards if we are already       at the top.      PageDown Fn + ArrowDown        Select bottom row in viewport or scroll one page down if we are already       at the bottom.      Ctrl + Home, Ctrl + End \u2318 + ArrowUp, \u2318 + ArrowDown Select first / last row."},{"location":"tutorial/tutorial_keyboard/#navigation-in-cell-nav-mode","title":"Navigation in Cell-Nav Mode","text":"<p>Cell-Nav mode is only available, when multiple columns are defined. In this mode we navigate the single grid cells in read-only mode mostly.  However, if the cell contains an embedded <code>&lt;input&gt;</code> element, we can focus that control and edit its content.</p> Windows macOS Function + / - Expand/collapse node if the title column is highlighted. ArrowUp, ArrowDown, ArrowLeft, ArrowRight        Navigate to adjacent cell. ArrowLeft on the leftmost column switches to \u2192Row Mode.      Tab,       Shift + Tab        Move to adjacent cell.      Escape        If the focus is inside an embedded <code>&lt;input&gt;</code> element:       discard changes and set focus to the outer cell.       Otherwise switch to \u2192Row Mode.      F2        Edit the current grid cell.       If the title column is highlighted, edit the node title.      Enter        If on the first column and node is expandable: toggle expansion.       If the cell contains an embedded <code>&lt;input&gt;</code> element:       set focus into that input control.       If the input control already had the focus, accept the entered data. Note: Enter behaves as alias for F2 on macOS if the       edit.trigger option list contains \"macEnter\".      AlphaNum        If the cell contains an embedded <code>&lt;input&gt;</code> element:       start editing its value.      Space        Toggle value if current cell contains a checkbox.       Toggle node selection if current cell is in the title column.      Home Fn + ArrowLeft  Select leftmost cell.  End Fn + ArrowRight  Select rightmost cell.  PageUp Fn + ArrowUp        Select top cell in viewport or scroll one page upwards if we are already       at the top.      PageDown Fn + ArrowDown        Select bottom cell in viewport or scroll one page down if we are already       at the bottom.      Ctrl + Home, Ctrl + End \u2318 + ArrowUp, \u2318 + ArrowDown Select top / bottom tree cell."},{"location":"tutorial/tutorial_keyboard/#configuration-and-customization","title":"Configuration and Customization","text":""},{"location":"tutorial/tutorial_keyboard/#related-tree-options","title":"Related Tree Options","text":"<pre><code>const tree = new Wunderbaum({\n  ...\n  enable: true,\n  autoActivate: true,\n  checkbox: true,\n  navigationModeOption: \"startRow\",  // | \"cell\" | \"startCell\" | \"row\"\n  quicksearch: true,\n  ...\n  // --- Events ---\n  keydown: (e) =&gt; {\n    // Return false to prevent default behavior\n  }\n  ...\n  edit: {\n    trigger: [\"F2\", \"macEnter\", ...],\n    ...\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_keyboard/#related-methods","title":"Related Methods","text":"<ul> <li><code>tree.setNavigationOption(mode: NavModeEnum)</code></li> <li><code>tree.setColumn(colIdx: number|string,  options?: SetColumnOptions)</code></li> <li><code>tree.setEnabled(flag: boolean)</code></li> </ul>"},{"location":"tutorial/tutorial_keyboard/#related-css-rules","title":"Related CSS Rules","text":"<pre><code>div.wunderbaum.wb-grid.wb-cell-mode div.wb-row.wb-active span.wb-col.wb-active {\n  /* Highlighted cell in cell-nav mode */\n}\n</code></pre>"},{"location":"tutorial/tutorial_keyboard/#code-hacks","title":"Code Hacks","text":""},{"location":"tutorial/tutorial_render/","title":"Custom Rendering","text":"<p>TL;DR</p> <p>Wunderbaum is rendered as nested <code>&lt;div&gt;</code>/<code>&lt;span&gt;</code> element structure. It can be customized by applying CSS styles.  Node icons are created from customizable icon fonts.</p> <p>This chapter describes different ways to customize the appearance of the tree.</p> <p>See also</p> <p>See also the Grid Tutorial for rendering of grid cell content and Edit Tutorial for rendering embedded input controls in grid cells.</p>"},{"location":"tutorial/tutorial_render/#custom-style-sheets","title":"Custom Style Sheets","text":"<p>It is possible to customize the appearance of the tree by adding specific CSS rules.</p> <p>For example, to change the background color of the active grid cell:</p> <pre><code>div.wunderbaum.wb-grid.wb-cell-mode div.wb-row.wb-active span.wb-col.wb-active {\n  /* Highlighted cell in cell-nav mode */\n}\n</code></pre> <p>See also</p> <p>See the Styling Tutorial for details.</p>"},{"location":"tutorial/tutorial_render/#custom-icons","title":"Custom Icons","text":"<p>This example uses Font Awesome Icons instead of the default Bootstrap Icons icon font:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css\"\n    /&gt;\n    ...\n  &lt;/head&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>const tree = new mar10.Wunderbaum({\n  element: document.getElementById(\"demo-tree\"),\n  source: \"get/root/nodes\",\n  iconMap: \"fontawesome6\",  // &lt;-- use Font Awesome Icons\n  ...\n});\n</code></pre> <p><code>iconMap</code> can also be a custom map of icon names, for example:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  ...\n  iconMap: {\n    error: \"bi bi-exclamation-triangle\",\n    loading: \"bi bi-chevron-right wb-busy\",\n    noData: \"bi bi-question-circle\",\n    expanderExpanded: \"bi bi-chevron-down\",\n    expanderCollapsed: \"bi bi-chevron-right\",\n    expanderLazy: \"bi bi-chevron-right wb-helper-lazy-expander\",\n    checkChecked: \"bi bi-check-square\",\n    checkUnchecked: \"bi bi-square\",\n    checkUnknown: \"bi bi-dash-square-dotted\",\n    radioChecked: \"bi bi-circle-fill\",\n    radioUnchecked: \"bi bi-circle\",\n    radioUnknown: \"bi bi-record-circle\",\n    folder: \"bi bi-folder2\",\n    folderOpen: \"bi bi-folder2-open\",\n    folderLazy: \"bi bi-folder-symlink\",\n    doc: \"bi bi-file-earmark\",\n    colSortable: \"bi bi-arrow-down-up\",\n    colSortAsc: \"bi bi-arrow-down\",\n    colSortDesc: \"bi bi-arrow-up\",\n    colFilter: \"bi bi-filter\",\n    colFilterActive: \"bi bi-filter-square-fill\",\n    colMenu: \"bi bi-three-dots-vertical\",\n   },\n  ...\n});\n</code></pre> <p>If we want to only override some default icons, this pattern can be used:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  ...\n  iconMap: Object.assign(Wunderbaum.iconMaps.bootstrap, {\n      folder: \"bi bi-archive\",\n    },\n  ),\n});\n</code></pre> <p>If the icon definition contains html markup (i.e. contains a <code>&lt;</code> character), the icon is rendered as HTML, otherwise it is rendered as a CSS class.</p> <pre><code>const tree = new mar10.Wunderbaum({\n  ...\n  iconMap: {\n    doc: \"&lt;i class='wb-icon'&gt;\ud83d\ude0d&lt;/i&gt;\",\n    expanderCollapsed: \"&lt;i class='wb-expander'&gt;\ud83e\udd14&lt;/i&gt;\",\n    expanderExpanded: \"&lt;i class='wb-expander'&gt;\ud83e\udd17&lt;/i&gt;\",\n    ...\n  },\n});\n</code></pre>"},{"location":"tutorial/tutorial_render/#custom-markup","title":"Custom Markup","text":""},{"location":"tutorial/tutorial_render/#using-the-render-event","title":"Using the <code>render</code> Event","text":"<p>The <code>render(e)</code> event is called for each node that needs to be rendered, i.e. that is materialized in the viewport. It is called after the node's row markup has been created, for example:</p> <pre><code>&lt;div class=\"wb-row\" style=\"top: 22px;\"&gt;\n  &lt;span class=\"wb-node wb-col wb-active\" style=\"left: 0px; width: 1368px;\"&gt;\n    &lt;i class=\"wb-indent\"&gt;&lt;/i&gt;\n    &lt;i class=\"wb-expander wb-indent\"&gt;&lt;/i&gt;\n    &lt;i class=\"wb-icon bi bi-file-earmark\"&gt;&lt;/i&gt;\n    &lt;span class=\"wb-title\" style=\"width: 1301px;\"&gt;Node 1.1&lt;/span&gt;\n  &lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>For treegrids with multiple columns, the row markup looks like this:</p> <pre><code>&lt;div class=\"wb-row wb-active wb-focus\" style=\"top: 66px;\"&gt;\n  &lt;span\n    class=\"wb-node wb-col wb-active\"\n    draggable=\"true\"\n    style=\"left: 0px; width: 250px;\"\n  &gt;\n    &lt;i class=\"wb-checkbox bi bi-square\"&gt;&lt;/i&gt;\n    &lt;i class=\"wb-indent\"&gt;&lt;/i&gt;\n    &lt;i class=\"wb-expander wb-indent\"&gt;&lt;/i&gt;\n    &lt;i class=\"wb-icon bi bi-file-earmark\"&gt;&lt;/i&gt;\n    &lt;span class=\"wb-title\" style=\"width: 163px;\"&gt;The Little Prince&lt;/span&gt;\n  &lt;/span&gt;\n  &lt;span class=\"wb-col\" style=\"left: 250px; width: 234.75px;\"&gt;\n    Antoine de Saint-Exupery\n  &lt;/span&gt;\n  &lt;span class=\"wb-col\" style=\"left: 484.75px; width: 50px;\"&gt;1943&lt;/span&gt;\n  &lt;span class=\"wb-col\" style=\"left: 534.75px; width: 50px;\"&gt;2946&lt;/span&gt;\n  &lt;span class=\"wb-col\" style=\"left: 584.75px; width: 80px;\"&gt;6.82&lt;/span&gt;\n  &lt;span class=\"wb-col\" style=\"left: 664.75px; width: 703.25px;\"&gt;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>e.nodeElem</code> property contains the HTML span element that represents the node title, and prefix icons: <code>&lt;span class=\"wb-node wb-col\"&gt; ... &lt;/span&gt;</code></p> <p>Info</p> <p>See WbRenderEventType for an overview of all event properties.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  render: function (e) {\n    const node = e.node;\n    const nodeElement = e.nodeElement; // HTMLSpanElement\n\n    console.log(e.type, e.isNew, e);\n    nodeElement.innerText = `${node.title}!`;\n  },\n});\n</code></pre> <p>Info</p> <p>The render event is especially useful to render the content of grid cells in treegrids. See also the Grid Tutorial and the Edit Tutorial for rendering of embedded input controls in grids.</p>"},{"location":"tutorial/tutorial_render/#badges","title":"Badges","text":"<p>Badges are small icons that can be displayed near the node title.  Example: Display the number of selected subnodes in the badge of collapsed parent:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  iconBadge: (e) =&gt; {\n    const node = e.node;\n    if (node.expanded || !node.children) {\n      return;\n    }\n    const count = node.children &amp;&amp; node.getSelectedNodes().length;\n    return {\n      badge: count,\n      badgeTooltip: `${count} selected`,\n      badgeClass: \"selection-count\",\n    };\n  },\n  ...\n});\n</code></pre> <pre><code>div.wunderbaum span.wb-badge.selection-count {\n  color: white;\n  background-color: green;\n}\n</code></pre> <p>You can also use e.g. \"data\" to control the badge and display an image instead of text.</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  iconBadge: (e) =&gt; {\n    if (e.node.data.badgeIcon) {\n      return {\n        badge: \"\",\n        badgeClass: \"wb-my-special-icon-\" + e.node.data.badgeIcon\n      };\n    }\n  },\n  ...\n});\n</code></pre> <pre><code>span.wb-my-special-icon-alert {\n  background-color: white !important;\n  background-image: url(\"img/alert.svg\");\n  width: 12px;\n  height: 12px;\n}\n</code></pre> <p>See also</p> <p>See also WbIconBadgeEventType and WbIconBadgeEventResultType.</p> <p>&lt;!-- ### Related Tree Options</p>"},{"location":"tutorial/tutorial_render/#related-methods","title":"Related Methods","text":"<ul> <li><code>util.toggleCheckbox()</code></li> </ul>"},{"location":"tutorial/tutorial_render/#related-css-rules","title":"Related CSS Rules","text":""},{"location":"tutorial/tutorial_render/#code-hacks","title":"Code Hacks","text":""},{"location":"tutorial/tutorial_render/#custom-badge-content","title":"Custom badge content","text":"<p>If needed, you can use completely custom elements like this:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  iconBadge: (e) =&gt; {\n    if (e.node.data.badgeIconPath) {\n      const badgeSpan = document.createElement(\"span\");\n      badgeSpan.className = \"tree-badge-icon\";\n      const badgeImg = document.createElement(\"img\");\n      badgeImg.src = e.node.data.badgeIconPath;\n      badgeSpan.appendChild(badgeImg);\n      return badgeSpan;\n    }\n  },\n  ...\n});\n</code></pre> <pre><code>div.wunderbaum span.tree-badge-icon {\n  position: absolute;\n  display: inline-block;\n  top: 0;\n  left: -0.6rem;\n  padding: 0.2em 0.3rem 0.1em 0.3rem;\n  font-size: 60%;\n  font-weight: 200;\n  line-height: 1;\n  text-align: center;\n  white-space: nowrap;\n  border-radius: 0.5rem;\n  pointer-events: none;\n}\n\ndiv.wunderbaum span.tree-badge-icon img {\n  width: 12px;\n  height: 12px;\n}\n</code></pre>"},{"location":"tutorial/tutorial_select/","title":"Selection","text":"<p>TL;DR</p> <p>Wunderbaum supports hierarchical selection, and radio-groups.</p>"},{"location":"tutorial/tutorial_select/#related-tree-options","title":"Related Tree Options","text":"<pre><code>const tree = new Wunderbaum({\n  // --- Common Options ---\n  selectMode: \"multi\",  // 'single', 'multi', 'hier'\n  checkbox: true, // boolean, \"radio\", or a callback\n  ...\n  // --- Common Events ---\n  beforeSelect: function (e) {\n    // return false to prevent selection\n  },\n  select: function (e) {\n    console.log(`Selected ${e.node}: ${e.flag}`);\n    console.log(\"Selected nodes:\", e.tree.getSelectedNodes());\n  },\n  ...\n});\n</code></pre> <p>See also</p> <p>See also the Selection Example.</p>"},{"location":"tutorial/tutorial_select/#related-node-properties","title":"Related Node Properties","text":"<pre><code>[\n  { title: \"Node 1\", selected: true },\n  { title: \"Node 2\", checkbox: true },\n  { title: \"Node 3\", unselectable: true, radiogroup: true\n    children: [\n      { title: \"Option 1\", selected: true },\n      { title: \"Option 2\" },\n    ]\n  },\n]\n</code></pre>"},{"location":"tutorial/tutorial_select/#related-methods","title":"Related Methods","text":"<ul> <li><code>node.fixSelection3AfterClick()</code></li> <li><code>node.fixSelection3FromEndNodes()</code></li> <li><code>node.getSelectedNodes()</code></li> <li><code>node.isSelected()</code></li> <li><code>node.setSelected(flag, options)</code></li> <li><code>node.toggleSelected()</code></li> <li><code>tree.getSelectedNodes()</code></li> <li><code>tree.selectAll(flag)</code></li> <li><code>tree.toggleSelect()</code></li> </ul>"},{"location":"tutorial/tutorial_select/#related-css-rules","title":"Related CSS Rules","text":""},{"location":"tutorial/tutorial_select/#code-hacks","title":"Code Hacks","text":"<p>Display the number of selected subnodes in the badge of collapsed parent:</p> <pre><code>const tree = new Wunderbaum({\n  ...\n  iconBadge: (e) =&gt; {\n    const node = e.node;\n    if (node.expanded || !node.children) {\n      return;\n    }\n    const count = node.children &amp;&amp; node.getSelectedNodes()?.length;\n    return {\n      badge: count,\n      badgeTooltip: `${count} selected`,\n      badgeClass: \"selection-count\",\n    };\n  },\n  ...\n});\n</code></pre> <pre><code>div.wunderbaum span.wb-badge.selection-count {\n  color: white;\n  background-color: green;\n}\n</code></pre>"},{"location":"tutorial/tutorial_source/","title":"Data Formats","text":"<p>TL;DR</p> <p>The node structure is defined as nested object structure. It is typically loaded via Ajax in JSON format.  Type- and attibute-maps allow for compact transfer.</p> <p>Some examples of how the data should be formatted in JSON.</p>"},{"location":"tutorial/tutorial_source/#nested-list-format","title":"Nested List Format","text":"<p>All node are transferred as a list of top-level nodes, with optional nested lists of child nodes.</p> <pre><code>[\n  {\n    title: \"Books\",\n    expanded: true,\n    children: [\n      {\n        title: \"Art of War\",\n        author: \"Sun Tzu\",\n      },\n      {\n        title: \"The Hobbit\",\n        author: \"J.R.R. Tolkien\",\n      },\n    ],\n  },\n  {\n    title: \"Music\",\n    children: [\n      {\n        title: \"Nevermind\",\n        author: \"Nirvana\",\n      },\n    ],\n  },\n];\n</code></pre>"},{"location":"tutorial/tutorial_source/#object-format","title":"Object Format","text":"<p>This is the most commonly used format. Here we pass an object that contains one <code>children</code> element, but also additional information.</p> <pre><code>{\n  \"types\": {...},\n  \"columns\": [...],\n  \"_keyMap\": {...},\n  \"children\": [\n    {\n      \"title\": \"Books\",\n      \"expanded\": true,\n      \"children\": [\n        {\n          \"title\": \"Art of War\",\n          \"author\": \"Sun Tzu\"\n        },\n      ]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"tutorial/tutorial_source/#type-information","title":"Type Information","text":"<p>A tree often contains multiple nodes that share attributes. We can extract type information to a separate block, in order to make the data model more concise:</p> <pre><code>{\n  \"types\": {\n    \"folder\": { \"icon\": \"bi bi-folder\", \"classes\": \"bold-style\" },\n    \"book\": { \"icon\": \"bi bi-book\" },\n    \"music\": { \"icon\": \"bi bi-disk\" }\n  },\n  \"children\": [\n    {\n      \"title\": \"Books\",\n      \"type\": \"folder\",\n      \"expanded\": true,\n      \"children\": [\n        {\n          \"title\": \"Art of War\",\n          \"type\": \"book\",\n          \"author\": \"Sun Tzu\"\n        },\n        ...\n      ]\n    },\n    {\n      \"title\": \"Music\",\n      \"type\": \"folder\",\n      \"children\": [\n        {\n          \"title\": \"Nevermind\",\n          \"type\": \"music\",\n          \"author\": \"Nirvana\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Type definitions can also be passed directly to the tree constructor:</p> <pre><code>const tree = new mar10.Wunderbaum({\n  id: \"demo\",\n  element: document.getElementById(\"demo-tree\"),\n  source: \"get/root/nodes\",\n  types: {\n    folder: { icon: \"bi bi-folder\", classes: \"bold-style\" },\n    book: { icon: \"bi bi-book\" },\n    music: { icon: \"bi bi-disk\" }\n  },\n  ...\n</code></pre>"},{"location":"tutorial/tutorial_source/#compact-formats","title":"Compact Formats","text":"<p>Load time of data is an important aspect of the user experience.  We can reduce the size of the JSON data by eliminating redundancy:</p> <ul> <li>Remove whitespace from the JSON (the listings in this chapter are formatted   for readability).</li> <li>Don't pass default values, e.g. <code>expanded: false</code> is not required.</li> <li>Use <code>node.type</code> declarations, to extract shared properties (see above).</li> </ul> <pre><code>{\n  \"_format\": \"nested\",\n  \"types\": {\"person\": {...}, ...},\n  \"children\": [\n    {\"title\": \"Node 1\", \"key\": \"id123\", \"type\": \"folder\", \"expanded\": true, \"children\": [\n      {\"title\": \"Node 1.1\", \"key\": \"id234\", \"type\": \"person\"},\n      {\"title\": \"Node 1.2\", \"key\": \"id345\", \"type\": \"person\", \"age\": 32}\n    ]}\n  ]\n}\n</code></pre> <p>The example above can still be optimized:</p> <ul> <li>Pass <code>1</code> instead of <code>true</code> and <code>0</code> instead of <code>false</code>   (or don't pass it at all if it is the default).</li> <li>Use <code>_keyMap</code> and shorten the key names, e.g. send <code>{\"t\": \"foo\"}</code> instead of   <code>{\"title\": \"foo\"}</code> (see below).</li> <li>Use a <code>_valueMap</code> to define a global list of potential string values for a distinct property type. Nodes can then pass a numeric index instead of the string, which will save space.</li> </ul> <p>Note</p> <p>The syntax of <code>_keyMap</code> and <code>_valueMap</code> has changed with v0.7.0.</p> <pre><code>{\n  \"_format\": \"nested\",  // Optional\n  \"types\": {\"person\": {...}, ...},\n  \"columns\": [...],\n  // Map from short key to final key (if a key is not found here it will\n  // be used literally):\n  \"_keyMap\": {\"title\": \"t\", \"key\": \"k\", \"type\": \"y\", \"children\": \"c\", \"expanded\": \"e\"},\n  // Optional: if a 'type' entry has a numeric value, use it as index into this\n  // list (string values are still used literally):\n  \"_valueMap\": {\n    \"type\": [\"folder\", \"person\"]\n  },\n  \"children\": [\n    {\"t\": \"Node 1\", \"k\": \"id123\", \"y\": 0, \"e\": 1, \"c\": [\n      {\"t\": \"Node 1.1\", \"k\": \"id234\", \"y\": 1},\n      {\"t\": \"Node 1.2\", \"k\": \"id345\", \"y\": 1, \"age\": 32}\n    ]}\n  ]\n}\n</code></pre>"},{"location":"tutorial/tutorial_source/#flat-parent-referencing-list","title":"Flat, Parent-Referencing List","text":"<p>The flat format is even a few percent smaller than the nested format. It may also be more apropropriate for sending patches for existing trees, since parent keys can be passed.</p> <p>Here all nodes are passed as a flat list, without nesting.  A node entry has the following structure:</p> <p><code>[PARENT_ID, [POSITIONAL_ARGS]]</code> or  <code>[PARENT_ID, [POSITIONAL_ARGS], {KEY_VALUE_ARGS}]</code></p> <p><code>PARENT_ID</code> is either a string that references an existing <code>node.key</code> or the numeric 0-based index of a node that appeared before in the list.</p> <p><code>POSITIONAL_ARGS</code> define property values in the order defined by <code>_positional</code>.</p> <p><code>KEY_VALUE_ARGS</code> define other properties as key/value pairs (optional).</p> <pre><code>source: {\n    // Define format as flat, parent-referencong list:\n    \"_format\": \"flat\",\n    // types are optional, but likely if `_valueMap` is used:\n    \"types\": { \"person\": { \"icon\": \"bi-person\" }, \"folder\": { \"icon\": \"bi-folder\" } },\n    // Map from short key to final key (if a key is not found here\n    // it will be used literally):\n    \"_keyMap\": { \"expanded\": \"e\" },\n    // Optional: Values for these keys are appended as list items (after the index).\n    // Other items - if any - are collected into one dict that is\n    // also appended:\n    \"_positional\": [\"title\", \"key\", \"type\"],\n    // Optional: if a 'type' entry has a numeric value, use it as\n    // index into this list (string values are still used literally):\n    \"_valueMap\": {\n        \"type\": [\"folder\", \"person\"]\n    },\n    // List index is 0-based, parent index null means 'top-node'.\n    // If parent index is a string, parent is searched by `node.key`\n    // (slower)\n    \"children\": [\n        [null, \"Node 1\", \"id123\", 0, { \"e\": true }],  // index=0, type=folder\n        [0, \"Node 1.1\", \"id234\", 1],                  // index=1, type=person\n        [0, \"Node 1.2\", \"id345\", 1, { \"age\": 32 }]    // index=2, type=person\n    ]\n},\n</code></pre> <p>See also</p> <p>This forum comment for an example of how to use the flat format.</p>"},{"location":"tutorial/tutorial_styling/","title":"Styling","text":"<p>TL;DR</p> <p>Common CSS classes allow custom styling and effects.</p>"},{"location":"tutorial/tutorial_styling/#feature-classes","title":"Feature Classes","text":"<p>We can add special classes to the tree's <code>&lt;div&gt;</code> container in order to enable custom behavior:</p> <ul> <li><code>wb-alternate</code>    Render even and odd rows in alternating background shades.</li> <li><code>wb-checkbox-auto-hide</code>    Apply CSS rules that hide unselected checkbox icons unless the mouse hovers   over a row.</li> <li><code>wb-fade-expander</code>    Apply CSS rules that show expander icons only while the mouse hovers over   the tree.</li> <li><code>wb-initializing</code>    This class is automatically removed when the tree is fully initialized.   Combining this class with other selectors allows to define CSS rules that only   apply during initial loading. See also <code>wb-skeleton</code>.</li> <li><code>wb-no-select</code>    Prevent text selection with the mouse (applies <code>user-select</code> CSS rule).</li> <li><code>wb-rainbow</code>    Colorize distinct indentation levels.</li> <li><code>wb-rtl</code>    Render the tree in right-to-left mode by flipping the behavior of <code>wb-helper-end</code>   and <code>wb-helper-start</code> classes.</li> </ul> <p>For example</p> <pre><code>&lt;div id=\"demo-tree\" class=\"... wb-no-select wb-checkbox-auto-hide\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"tutorial/tutorial_styling/#automatic-styles","title":"Automatic Styles","text":"<p>These classes are automatically set on the tree's <code>&lt;div&gt;</code> container, depending on the current mode, allowing for custom CSS rules:</p> <ul> <li><code>wb-grid</code></li> <li><code>wb-fixed-col</code></li> <li><code>wb-cell-mode</code></li> </ul> <p>These classes are automatically set for distinct rows, allowing custom CSS rules:</p> <ul> <li><code>wb-active</code></li> <li><code>wb-busy</code></li> <li><code>wb-error</code></li> <li><code>wb-invalid</code></li> <li><code>wb-loading</code></li> <li><code>wb-match</code></li> <li><code>wb-selected</code></li> <li><code>wb-skeleton</code>    Added to rows, when the skeleton tree option is true.   Applies CSS styles that render titles as glowing placeholders.   (Typically combined with <code>wb-initializing</code>.)</li> <li><code>wb-status-STATUS</code>, e.g. <code>wb-status-error</code></li> <li><code>wb-submatch</code></li> </ul> <p>These classes are automatically set for distinct column spans, allowing custom CSS rules:</p> <ul> <li><code>wb-active</code></li> <li><code>wb-busy</code></li> <li><code>wb-error</code></li> <li><code>wb-invalid</code></li> </ul> <pre><code>todo: example;\n</code></pre>"},{"location":"tutorial/tutorial_styling/#helper-classes","title":"Helper Classes","text":"<p>This classes can be added to column definitions in order to enable custom formatting:</p> <ul> <li><code>wb-helper-center</code>    Align cell content to the center.</li> <li><code>wb-helper-disabled</code>    Apply disabled style to cell content, i.e. render in a dimmed color.</li> <li><code>wb-helper-end</code>    Align cell content to the right (unless <code>wb-rtl</code> is set on the container).</li> <li><code>wb-helper-hidden</code>    Hide element content.</li> <li><code>wb-helper-invalid</code>    Apply invalid style to cell content, i.e. render in red.</li> <li><code>wb-helper-lazy-expander</code>    Can be used in iconMaps to make a font icon appear colored.</li> <li><code>wb-helper-link</code>    Apply link style to cell content.</li> <li><code>wb-helper-start</code>    Align cell content to the left (unless <code>wb-rtl</code> is set on the container).</li> </ul>"},{"location":"tutorial/tutorial_styling/#css-variables","title":"CSS Variables","text":"<p>Many CSS styles can be accessed and modified using JavaScript like so:</p> <pre><code>document.body.style.setProperty(\"--wb-node-text-color\", \"#ff00ff\");\ndocument\n  .querySelector(\"#tree\")\n  .style.setProperty(\"--wb-font-stack\", \"monospace\");\n</code></pre> <p>See <code>wunderbaum.scss</code> for a complete list of all availabe CSS variables.</p>"},{"location":"tutorial/tutorial_styling/#css-hacks","title":"CSS Hacks","text":"<p>See also</p> <p>See also the Render Tutorial for details on the markup structure and used class names.</p> <pre><code>div.wunderbaum {\n  scroll-behavior: smooth;\n}\n</code></pre> <pre><code>/* Show tree skeleton while initializing. */\ndiv.wunderbaum.wb-skeleton.wb-initializing {\n  background-position-y: 20px;\n  background-image: url(\"skeleton-transp.png\");\n  background-repeat: no-repeat;\n}\n</code></pre> <pre><code>* {\n  padding: 0;\n  margin: 0;\n  /* prevent scrollbars, which would break `100vh` */\n  overflow: hidden;\n}\n</code></pre> <pre><code>div.wunderbaum:focus-visible {\n  /* Suppress system focus outline. */\n  outline-style: none;\n}\n</code></pre>"}]}